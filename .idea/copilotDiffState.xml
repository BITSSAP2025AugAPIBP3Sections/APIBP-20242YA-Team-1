<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Frontend/src/contexts/AuthContext.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Frontend/src/contexts/AuthContext.tsx" />
              <option name="originalContent" value="import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';&#10;const AUTH_SERVICE_URL = import.meta.env.VITE_AUTH_SERVICE_URL;&#10;&#10;// Simple user shape&#10;export interface User {&#10;  id: string;&#10;  username: string;&#10;  email: string;&#10;}&#10;&#10;interface AuthResult { success: boolean; error?: string }&#10;&#10;interface AuthContextType {&#10;  user: User | null;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;  signUp: (email: string, password: string, fullName: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  signIn: (email: string, password: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  resetPassword: (email: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  signOut: () =&gt; void;&#10;  signInWithGoogle: () =&gt; Promise&lt;AuthResult&gt;;&#10;}&#10;&#10;const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);&#10;&#10;interface AuthProviderProps { children: ReactNode }&#10;&#10;export const AuthProvider = ({ children }: AuthProviderProps) =&gt; {  &#10;  const [user, setUser] = useState&lt;User | null&gt;(null);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const fetchUser = async () =&gt; {&#10;      try {&#10;        const resp = await fetch(`${AUTH_SERVICE_URL}/auth/me`, {&#10;          credentials: 'include', // sends cookies&#10;        });&#10;        const data = await resp.json();&#10;        if (data.isAuthenticated &amp;&amp; data.user) {&#10;          setUser(data.user)&#10;        } else {&#10;          setUser(null);&#10;        }&#10;      } catch (e) {&#10;        console.error('Session check failed:', e);&#10;        setUser(null);&#10;      } finally {&#10;        setIsLoading(false);&#10;      }&#10;    };&#10;    fetchUser();&#10;  }, []);&#10;&#10;  const signUp: AuthContextType['signUp'] = async (email, password, fullName) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;    try {&#10;      const resp = await fetch(`${AUTH_SERVICE_URL}/register`, {&#10;        method: 'POST',&#10;        headers: { 'Content-Type': 'application/json' },&#10;        credentials: 'include',&#10;        body: JSON.stringify({ email, password, username: fullName })&#10;      });&#10;&#10;      const data = await resp.json();&#10;      if (!resp.ok) {&#10;        return { success: false, error: data.error || 'Registration failed' };&#10;      }&#10;&#10;      if (data.user) {&#10;        setUser(data.user);&#10;      }&#10;&#10;      return { success: true };&#10;    } catch (e) {&#10;      return { success: false, error: 'Network error' };&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const signIn: AuthContextType['signIn'] = async (email, password) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;    try {&#10;      const resp = await fetch(`${AUTH_SERVICE_URL}/login`, {&#10;        method: 'POST',&#10;        headers: { 'Content-Type': 'application/json' },&#10;        credentials: 'include',&#10;        body: JSON.stringify({ email, password })&#10;      });&#10;      const data = await resp.json();&#10;      if (!resp.ok) {&#10;        const err = data.error || 'Invalid credentials';&#10;        setError(err);&#10;        return { success: false, error: err };&#10;      }&#10;&#10;      if (data.user) {&#10;        setUser(data.user);&#10;      } &#10;&#10;      return { success: true };&#10;    } catch (e) {&#10;      const err = 'Login failed';&#10;      setError(err);&#10;      return { success: false, error: err };&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const signInWithGoogle: AuthContextType['signInWithGoogle'] = async () =&gt; {&#10;    try {&#10;      const response = await fetch(`${AUTH_SERVICE_URL}/auth/login`, {&#10;        credentials: &quot;include&quot;,&#10;      });&#10;  &#10;      const data = await response.json();&#10;  &#10;      if (data.auth_url) {&#10;        // redirect to Google's OAuth URL&#10;        window.location.href = data.auth_url;&#10;        return { success: true };&#10;      } else {&#10;        return { success: false, error: 'Google auth URL not received' };&#10;      }&#10;    } catch (e) {&#10;      console.error('Google login error:', e);&#10;      return { success: false, error: 'Network error during Google login' };&#10;    }&#10;  };&#10;&#10;  const resetPassword: AuthContextType['resetPassword'] = async (email) =&gt; {&#10;    return { success: true }; &#10;  };&#10;&#10;  const signOut = async () =&gt; {&#10;    try {&#10;      await fetch(`${AUTH_SERVICE_URL}/auth/logout`, {&#10;        method: 'POST',&#10;        credentials: 'include', &#10;      });&#10;    } catch (e) {&#10;      console.warn('Logout request failed:', e);&#10;    } finally {&#10;      setUser(null);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={{ user, isLoading, error, signUp, signIn, resetPassword, signOut, signInWithGoogle }}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export const useAuth = () =&gt; {&#10;  const ctx = useContext(AuthContext);&#10;  if (!ctx) throw new Error('useAuth must be used within AuthProvider');&#10;  return ctx;&#10;};&#10;" />
              <option name="updatedContent" value="import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';&#10;const AUTH_SERVICE_URL = import.meta.env.VITE_AUTH_SERVICE_URL;&#10;&#10;// Simple user shape&#10;export interface User {&#10;  id: string;&#10;  username: string;&#10;  email: string;&#10;}&#10;&#10;interface AuthResult { success: boolean; error?: string }&#10;&#10;interface AuthContextType {&#10;  user: User | null;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;  signUp: (email: string, password: string, fullName: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  signIn: (email: string, password: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  resetPassword: (email: string) =&gt; Promise&lt;AuthResult&gt;;&#10;  signOut: () =&gt; void;&#10;  signInWithGoogle: () =&gt; Promise&lt;AuthResult&gt;;&#10;}&#10;&#10;const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);&#10;&#10;interface AuthProviderProps { children: ReactNode }&#10;&#10;export const AuthProvider = ({ children }: AuthProviderProps) =&gt; {  &#10;  const [user, setUser] = useState&lt;User | null&gt;(null);&#10;  const [isLoading, setIsLoading] = useState(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const fetchUser = async () =&gt; {&#10;      try {&#10;        const resp = await fetch(`${AUTH_SERVICE_URL}/api/v1/auth/me`, {&#10;          credentials: 'include', // sends cookies&#10;        });&#10;        const data = await resp.json();&#10;        if (data.isAuthenticated &amp;&amp; data.user) {&#10;          setUser(data.user)&#10;        } else {&#10;          setUser(null);&#10;        }&#10;      } catch (e) {&#10;        console.error('Session check failed:', e);&#10;        setUser(null);&#10;      } finally {&#10;        setIsLoading(false);&#10;      }&#10;    };&#10;    fetchUser();&#10;  }, []);&#10;&#10;  const signUp: AuthContextType['signUp'] = async (email, password, fullName) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;    try {&#10;      const resp = await fetch(`${AUTH_SERVICE_URL}/api/v1/register`, {&#10;        method: 'POST',&#10;        headers: { 'Content-Type': 'application/json' },&#10;        credentials: 'include',&#10;        body: JSON.stringify({ email, password, username: fullName })&#10;      });&#10;&#10;      const data = await resp.json();&#10;      if (!resp.ok) {&#10;        return { success: false, error: data.error || 'Registration failed' };&#10;      }&#10;&#10;      if (data.user) {&#10;        setUser(data.user);&#10;      }&#10;&#10;      return { success: true };&#10;    } catch (e) {&#10;      return { success: false, error: 'Network error' };&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const signIn: AuthContextType['signIn'] = async (email, password) =&gt; {&#10;    setIsLoading(true);&#10;    setError(null);&#10;    try {&#10;      const resp = await fetch(`${AUTH_SERVICE_URL}/api/v1/login`, {&#10;        method: 'POST',&#10;        headers: { 'Content-Type': 'application/json' },&#10;        credentials: 'include',&#10;        body: JSON.stringify({ email, password })&#10;      });&#10;      const data = await resp.json();&#10;      if (!resp.ok) {&#10;        const err = data.error || 'Invalid credentials';&#10;        setError(err);&#10;        return { success: false, error: err };&#10;      }&#10;&#10;      if (data.user) {&#10;        setUser(data.user);&#10;      } &#10;&#10;      return { success: true };&#10;    } catch (e) {&#10;      const err = 'Login failed';&#10;      setError(err);&#10;      return { success: false, error: err };&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  const signInWithGoogle: AuthContextType['signInWithGoogle'] = async () =&gt; {&#10;    try {&#10;      const response = await fetch(`${AUTH_SERVICE_URL}/api/v1/auth/login`, {&#10;        credentials: &quot;include&quot;,&#10;      });&#10;  &#10;      const data = await response.json();&#10;  &#10;      if (data.auth_url) {&#10;        // redirect to Google's OAuth URL&#10;        window.location.href = data.auth_url;&#10;        return { success: true };&#10;      } else {&#10;        return { success: false, error: 'Google auth URL not received' };&#10;      }&#10;    } catch (e) {&#10;      console.error('Google login error:', e);&#10;      return { success: false, error: 'Network error during Google login' };&#10;    }&#10;  };&#10;&#10;  const resetPassword: AuthContextType['resetPassword'] = async (email) =&gt; {&#10;    return { success: true }; &#10;  };&#10;&#10;  const signOut = async () =&gt; {&#10;    try {&#10;      await fetch(`${AUTH_SERVICE_URL}/api/v1/auth/logout`, {&#10;        method: 'POST',&#10;        credentials: 'include', &#10;      });&#10;    } catch (e) {&#10;      console.warn('Logout request failed:', e);&#10;    } finally {&#10;      setUser(null);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;AuthContext.Provider value={{ user, isLoading, error, signUp, signIn, resetPassword, signOut, signInWithGoogle }}&gt;&#10;      {children}&#10;    &lt;/AuthContext.Provider&gt;&#10;  );&#10;};&#10;&#10;export const useAuth = () =&gt; {&#10;  const ctx = useContext(AuthContext);&#10;  if (!ctx) throw new Error('useAuth must be used within AuthProvider');&#10;  return ctx;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/authentication-service/src/controllers/auth_controller.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/authentication-service/src/controllers/auth_controller.py" />
              <option name="originalContent" value="from flask import Blueprint, jsonify, redirect, request&#10;import os&#10;from dotenv import load_dotenv&#10;&#10;load_dotenv()&#10;&#10;try:&#10;    from ..services.google_auth_service import GoogleAuthService&#10;    from ..services.user_auth_service import UserAuthService&#10;except ImportError:&#10;    from services.google_auth_service import GoogleAuthService&#10;    from services.user_auth_service import UserAuthService&#10;&#10;auth_bp = Blueprint(&quot;auth_bp&quot;, __name__)&#10;google_auth_service = GoogleAuthService()&#10;user_auth_service = UserAuthService()&#10;&#10;@auth_bp.route(&quot;/auth/login&quot;, methods=[&quot;GET&quot;])&#10;def login():&#10;    auth_url = google_auth_service.get_authorization_url()&#10;    return jsonify({&quot;auth_url&quot;: auth_url})&#10;&#10;@auth_bp.route(&quot;/oauth2callback&quot;)&#10;def callback():&#10;    code = request.args.get(&quot;code&quot;)&#10;    credentials = google_auth_service.exchange_code_for_token(code)&#10;    if not credentials:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid credentials&quot;}), 400&#10;&#10;    token_info = google_auth_service.verify_token(credentials.id_token)&#10;    if not token_info:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid token&quot;}), 400&#10;&#10;    email = token_info.get(&quot;email&quot;)&#10;    google_id = token_info.get(&quot;sub&quot;)  # Google's unique user ID&#10;    username = token_info.get(&quot;name&quot;) or token_info.get(&quot;given_name&quot;) or (email.split(&quot;@&quot;)[0] if email else None)&#10;&#10;    if not email or not google_id:&#10;        return jsonify({&quot;error&quot;: &quot;Incomplete token data&quot;}), 400&#10;&#10;    user = user_auth_service.upsert_google_user(email, google_id, username)&#10;    tokens = user_auth_service.generate_tokens_for_user(user)&#10;    &#10;    cookie_secure_env = os.getenv(&quot;COOKIE_SECURE&quot;, &quot;True&quot;)  &#10;    cookie_secure = cookie_secure_env.lower() in (&quot;true&quot;, &quot;1&quot;, &quot;yes&quot;) &#10;&#10;    response = redirect(f&quot;{os.getenv('FRONTEND_URL')}/&quot;)&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        tokens[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=cookie_secure,&#10;        samesite=&quot;Lax&quot;&#10;    )&#10;    response.set_cookie(&#10;        &quot;refresh_token&quot;,&#10;        tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=cookie_secure,&#10;        samesite=&quot;Lax&quot;&#10;    )&#10;    return response&#10;&#10;&#10;@auth_bp.route(&quot;/auth/logout&quot;, methods=[&quot;POST&quot;])&#10;def logout():&#10;    response = jsonify({&quot;message&quot;: &quot;Logged out successfully&quot;})&#10;    response.delete_cookie(&quot;access_token&quot;)&#10;    response.delete_cookie(&quot;refresh_token&quot;)&#10;    return response&#10;&#10;@auth_bp.route(&quot;/login&quot;, methods=[&quot;POST&quot;])&#10;def login_email():&#10;    data = request.get_json() or {}&#10;    email = data.get(&quot;email&quot;)&#10;    password = data.get(&quot;password&quot;)&#10;&#10;    success, auth_response = user_auth_service.authenticate(email, password)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: auth_response}), 400&#10;&#10;    # authenticate now returns the token payload directly (no nested 'tokens' key)&#10;    tokens = auth_response  # contains access_token, refresh_token, token_type, user&#10;    response = jsonify({&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: tokens[&quot;user&quot;][&quot;id&quot;],&#10;            &quot;email&quot;: email,&#10;            &quot;username&quot;: tokens[&quot;user&quot;].get(&quot;username&quot;)&#10;        },&#10;        &quot;message&quot;: &quot;Logged in successfully&quot;&#10;    })&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        tokens[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=3600&#10;    )&#10;    response.set_cookie(&#10;        &quot;refresh_token&quot;,&#10;        tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=30 * 24 * 3600&#10;    )&#10;    return response, 200&#10;&#10;&#10;@auth_bp.route(&quot;/register&quot;, methods=[&quot;POST&quot;])&#10;def register():&#10;    data = request.get_json() or {}&#10;    email = data.get(&quot;email&quot;)&#10;    password = data.get(&quot;password&quot;)&#10;    username = data.get(&quot;username&quot;)&#10;&#10;    success, message = user_auth_service.register_user(email, password, username)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: message}), 400&#10;&#10;    auth_success, tokens = user_auth_service.authenticate(email, password)&#10;    if not auth_success:&#10;        return jsonify({&quot;message&quot;: &quot;Registered successfully, but login failed&quot;}), 201&#10;&#10;    response = jsonify({&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: tokens[&quot;user&quot;][&quot;id&quot;],&#10;            &quot;email&quot;: email,&#10;            &quot;username&quot;: username&#10;        },&#10;        &quot;message&quot;: &quot;Registered successfully&quot;&#10;    })&#10;    response.set_cookie(&quot;access_token&quot;, tokens[&quot;access_token&quot;], httponly=True, secure=True, samesite=&quot;Lax&quot;, max_age=3600)&#10;    response.set_cookie(&quot;refresh_token&quot;, tokens[&quot;refresh_token&quot;], httponly=True, secure=True, samesite=&quot;Lax&quot;, max_age=30 * 24 * 3600)&#10;    return response, 201&#10;&#10;&#10;@auth_bp.route(&quot;/delete-user&quot;, methods=[&quot;DELETE&quot;]) &#10;def delete_user():&#10;    data = request.get_json() or {}&#10;    user_id = data.get(&quot;user_id&quot;)&#10;    success, message = user_auth_service.delete_user(user_id)&#10;    if success:&#10;        return jsonify({&quot;message&quot;: message}), 200&#10;    return jsonify({&quot;error&quot;: message}), 404&#10;&#10;@auth_bp.route(&quot;/users&quot;, methods=[&quot;GET&quot;])&#10;def list_users():&#10;    users = user_auth_service.list_users()&#10;    return jsonify({&quot;users&quot;: users}), 200&#10;&#10;@auth_bp.route(&quot;/auth/refresh&quot;, methods=[&quot;POST&quot;])&#10;def refresh():&#10;    refresh_token = (&#10;        request.cookies.get(&quot;refresh_token&quot;)&#10;        or (request.get_json() or {}).get(&quot;refresh_token&quot;)&#10;    )&#10;    if not refresh_token:&#10;        return jsonify({&quot;error&quot;: &quot;Missing refresh token&quot;}), 400&#10;    &#10;    success, result = user_auth_service.refresh_tokens(refresh_token)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: result}), 401&#10;    &#10;    response = jsonify(result)&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        result[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=3600&#10;    )&#10;    return response, 200&#10;&#10;@auth_bp.route(&quot;/auth/me&quot;, methods=[&quot;GET&quot;])&#10;def get_current_user():&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    # Use instance method correctly&#10;    valid, payload = user_auth_service.verify_token(access_token)&#10;    if not valid or payload.get(&quot;type&quot;) != &quot;access&quot;:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    try:&#10;        user_id = int(payload.get(&quot;sub&quot;))&#10;    except (TypeError, ValueError):&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    user = user_auth_service.get_user_by_id(user_id)&#10;    if not user:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    return jsonify({&#10;        &quot;isAuthenticated&quot;: True,&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: user[&quot;id&quot;],&#10;            &quot;username&quot;: user[&quot;username&quot;],&#10;            &quot;email&quot;: user[&quot;email&quot;],&#10;        }&#10;    }), 200&#10;" />
              <option name="updatedContent" value="from flask import Blueprint, jsonify, redirect, request&#10;import os&#10;from dotenv import load_dotenv&#10;&#10;load_dotenv()&#10;&#10;try:&#10;    from ..services.google_auth_service import GoogleAuthService&#10;    from ..services.user_auth_service import UserAuthService&#10;except ImportError:&#10;    from services.google_auth_service import GoogleAuthService&#10;    from services.user_auth_service import UserAuthService&#10;&#10;auth_bp = Blueprint(&quot;auth_bp&quot;, __name__)&#10;google_auth_service = GoogleAuthService()&#10;user_auth_service = UserAuthService()&#10;&#10;@auth_bp.route(&quot;/api/v1/auth/login&quot;, methods=[&quot;GET&quot;])&#10;def login():&#10;    auth_url = google_auth_service.get_authorization_url()&#10;    return jsonify({&quot;auth_url&quot;: auth_url})&#10;&#10;@auth_bp.route(&quot;/api/v1/oauth2callback&quot;)&#10;def callback():&#10;    code = request.args.get(&quot;code&quot;)&#10;    credentials = google_auth_service.exchange_code_for_token(code)&#10;    if not credentials:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid credentials&quot;}), 400&#10;&#10;    token_info = google_auth_service.verify_token(credentials.id_token)&#10;    if not token_info:&#10;        return jsonify({&quot;error&quot;: &quot;Invalid token&quot;}), 400&#10;&#10;    email = token_info.get(&quot;email&quot;)&#10;    google_id = token_info.get(&quot;sub&quot;)  # Google's unique user ID&#10;    username = token_info.get(&quot;name&quot;) or token_info.get(&quot;given_name&quot;) or (email.split(&quot;@&quot;)[0] if email else None)&#10;&#10;    if not email or not google_id:&#10;        return jsonify({&quot;error&quot;: &quot;Incomplete token data&quot;}), 400&#10;&#10;    user = user_auth_service.upsert_google_user(email, google_id, username)&#10;    tokens = user_auth_service.generate_tokens_for_user(user)&#10;    &#10;    cookie_secure_env = os.getenv(&quot;COOKIE_SECURE&quot;, &quot;True&quot;)  &#10;    cookie_secure = cookie_secure_env.lower() in (&quot;true&quot;, &quot;1&quot;, &quot;yes&quot;) &#10;&#10;    response = redirect(f&quot;{os.getenv('FRONTEND_URL')}/&quot;)&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        tokens[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=cookie_secure,&#10;        samesite=&quot;Lax&quot;&#10;    )&#10;    response.set_cookie(&#10;        &quot;refresh_token&quot;,&#10;        tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=cookie_secure,&#10;        samesite=&quot;Lax&quot;&#10;    )&#10;    return response&#10;&#10;&#10;@auth_bp.route(&quot;/api/v1/auth/logout&quot;, methods=[&quot;POST&quot;])&#10;def logout():&#10;    response = jsonify({&quot;message&quot;: &quot;Logged out successfully&quot;})&#10;    response.delete_cookie(&quot;access_token&quot;)&#10;    response.delete_cookie(&quot;refresh_token&quot;)&#10;    return response&#10;&#10;@auth_bp.route(&quot;/api/v1/login&quot;, methods=[&quot;POST&quot;])&#10;def login_email():&#10;    data = request.get_json() or {}&#10;    email = data.get(&quot;email&quot;)&#10;    password = data.get(&quot;password&quot;)&#10;&#10;    success, auth_response = user_auth_service.authenticate(email, password)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: auth_response}), 400&#10;&#10;    # authenticate now returns the token payload directly (no nested 'tokens' key)&#10;    tokens = auth_response  # contains access_token, refresh_token, token_type, user&#10;    response = jsonify({&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: tokens[&quot;user&quot;][&quot;id&quot;],&#10;            &quot;email&quot;: email,&#10;            &quot;username&quot;: tokens[&quot;user&quot;].get(&quot;username&quot;)&#10;        },&#10;        &quot;message&quot;: &quot;Logged in successfully&quot;&#10;    })&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        tokens[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=3600&#10;    )&#10;    response.set_cookie(&#10;        &quot;refresh_token&quot;,&#10;        tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=30 * 24 * 3600&#10;    )&#10;    return response, 200&#10;&#10;&#10;@auth_bp.route(&quot;/api/v1/register&quot;, methods=[&quot;POST&quot;])&#10;def register():&#10;    data = request.get_json() or {}&#10;    email = data.get(&quot;email&quot;)&#10;    password = data.get(&quot;password&quot;)&#10;    username = data.get(&quot;username&quot;)&#10;&#10;    success, message = user_auth_service.register_user(email, password, username)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: message}), 400&#10;&#10;    auth_success, tokens = user_auth_service.authenticate(email, password)&#10;    if not auth_success:&#10;        return jsonify({&quot;message&quot;: &quot;Registered successfully, but login failed&quot;}), 201&#10;&#10;    response = jsonify({&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: tokens[&quot;user&quot;][&quot;id&quot;],&#10;            &quot;email&quot;: email,&#10;            &quot;username&quot;: username&#10;        },&#10;        &quot;message&quot;: &quot;Registered successfully&quot;&#10;    })&#10;    response.set_cookie(&quot;access_token&quot;, tokens[&quot;access_token&quot;], httponly=True, secure=True, samesite=&quot;Lax&quot;, max_age=3600)&#10;    response.set_cookie(&quot;refresh_token&quot;, tokens[&quot;refresh_token&quot;], httponly=True, secure=True, samesite=&quot;Lax&quot;, max_age=30 * 24 * 3600)&#10;    return response, 201&#10;&#10;&#10;@auth_bp.route(&quot;/api/v1/delete-user&quot;, methods=[&quot;DELETE&quot;]) &#10;def delete_user():&#10;    data = request.get_json() or {}&#10;    user_id = data.get(&quot;user_id&quot;)&#10;    success, message = user_auth_service.delete_user(user_id)&#10;    if success:&#10;        return jsonify({&quot;message&quot;: message}), 200&#10;    return jsonify({&quot;error&quot;: message}), 404&#10;&#10;@auth_bp.route(&quot;/api/v1/users&quot;, methods=[&quot;GET&quot;])&#10;def list_users():&#10;    users = user_auth_service.list_users()&#10;    return jsonify({&quot;users&quot;: users}), 200&#10;&#10;@auth_bp.route(&quot;/api/v1/auth/refresh&quot;, methods=[&quot;POST&quot;])&#10;def refresh():&#10;    refresh_token = (&#10;        request.cookies.get(&quot;refresh_token&quot;)&#10;        or (request.get_json() or {}).get(&quot;refresh_token&quot;)&#10;    )&#10;    if not refresh_token:&#10;        return jsonify({&quot;error&quot;: &quot;Missing refresh token&quot;}), 400&#10;    &#10;    success, result = user_auth_service.refresh_tokens(refresh_token)&#10;    if not success:&#10;        return jsonify({&quot;error&quot;: result}), 401&#10;    &#10;    response = jsonify(result)&#10;    response.set_cookie(&#10;        &quot;access_token&quot;,&#10;        result[&quot;access_token&quot;],&#10;        httponly=True,&#10;        secure=True,&#10;        samesite=&quot;Lax&quot;,&#10;        max_age=3600&#10;    )&#10;    return response, 200&#10;&#10;@auth_bp.route(&quot;/api/v1/auth/me&quot;, methods=[&quot;GET&quot;])&#10;def get_current_user():&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    # Use instance method correctly&#10;    valid, payload = user_auth_service.verify_token(access_token)&#10;    if not valid or payload.get(&quot;type&quot;) != &quot;access&quot;:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    try:&#10;        user_id = int(payload.get(&quot;sub&quot;))&#10;    except (TypeError, ValueError):&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    user = user_auth_service.get_user_by_id(user_id)&#10;    if not user:&#10;        return jsonify({&quot;isAuthenticated&quot;: False, &quot;user&quot;: None}), 200&#10;&#10;    return jsonify({&#10;        &quot;isAuthenticated&quot;: True,&#10;        &quot;user&quot;: {&#10;            &quot;id&quot;: user[&quot;id&quot;],&#10;            &quot;username&quot;: user[&quot;username&quot;],&#10;            &quot;email&quot;: user[&quot;email&quot;],&#10;        }&#10;    }), 200" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/authentication-service/src/routes/swagger_auth_service.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/authentication-service/src/routes/swagger_auth_service.yaml" />
              <option name="originalContent" value="swagger: &quot;2.0&quot;&#10;info:&#10;  title: Google &amp; Email/Password Authentication Service API&#10;  version: 1.2.0&#10;  description: &gt;&#10;    This service handles Google OAuth2 authentication flow and simple email/password registration &amp; login.&#10;host: localhost:4001&#10;basePath: /&#10;schemes:&#10;  - http&#10;&#10;servers:&#10;  - url: http://localhost:4001&#10;    description: Local development server&#10;    &#10;paths:&#10;  /auth/login:&#10;    get:&#10;      summary: Generate Google OAuth2 Authorization URL&#10;      description: Returns the Google OAuth2 consent screen URL where the user will log in.&#10;      tags:&#10;        - Google OAuth&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Authorization URL generated&#10;          schema:&#10;            type: object&#10;            properties:&#10;              auth_url:&#10;                type: string&#10;&#10;  /login:&#10;    post:&#10;      summary: Login with email and password&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: credentials&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              email:&#10;                type: string&#10;              password:&#10;                type: string&#10;            required:&#10;              - email&#10;              - password&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Login successful (sets httpOnly access &amp; refresh token cookies)&#10;          schema:&#10;            $ref: '#/definitions/EmailLoginSuccess'&#10;        &quot;400&quot;:&#10;          description: Invalid credentials&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /register:&#10;    post:&#10;      summary: Register a new user with email, password, and username&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: user&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              email:&#10;                type: string&#10;              password:&#10;                type: string&#10;              username:&#10;                type: string&#10;            required:&#10;              - email&#10;              - password&#10;              - username&#10;      responses:&#10;        &quot;201&quot;:&#10;          description: User registered successfully. If auto-login succeeds returns tokens; otherwise returns a message.&#10;          schema:&#10;            $ref: '#/definitions/RegisterSuccess'&#10;        &quot;400&quot;:&#10;          description: Registration failed&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /oauth2callback:&#10;    get:&#10;      summary: Handle Google OAuth2 Callback&#10;      description: Exchanges authorization code for tokens, verifies them, sets httpOnly cookies, and redirects to frontend.&#10;      tags:&#10;        - Google OAuth&#10;      parameters:&#10;        - name: code&#10;          in: query&#10;          required: true&#10;          type: string&#10;          description: Authorization code returned by Google&#10;      responses:&#10;        &quot;302&quot;:&#10;          description: &quot;Redirect to frontend dashboard on successful authentication (cookies set: access_token, refresh_token)&quot;&#10;        &quot;400&quot;:&#10;          description: Invalid credentials or token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /auth/logout:&#10;    post:&#10;      summary: Log out the authenticated user&#10;      description: Removes auth cookies (access_token, refresh_token) and returns a message.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Logout successful&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;&#10;  /delete-user:&#10;    delete:&#10;      summary: Delete a user by ID&#10;      description: Permanently removes a user from the database.&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: user&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              user_id:&#10;                type: integer&#10;                example: 3&#10;            required:&#10;              - user_id&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: User deleted&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;        &quot;404&quot;:&#10;          description: User not found&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /:&#10;    get:&#10;      summary: Health Check&#10;      description: Check if the Authentication Service is running.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Service running successfully&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;&#10;  /users:&#10;    get:&#10;      summary: List all users&#10;      description: Returns an array of all registered users.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Users fetched successfully&#10;          schema:&#10;            type: object&#10;            properties:&#10;              users:&#10;                type: array&#10;                items:&#10;                  $ref: '#/definitions/User'&#10;&#10;  /auth/refresh:&#10;    post:&#10;      summary: Refresh access token&#10;      description: Accepts a refresh token from cookie or request body and returns new access &amp; refresh tokens.&#10;      tags:&#10;        - Utility&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: refresh&#10;          required: false&#10;          schema:&#10;            type: object&#10;            properties:&#10;              refresh_token:&#10;                type: string&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Tokens refreshed successfully (sets new access_token cookie)&#10;          schema:&#10;            $ref: '#/definitions/TokensResponse'&#10;        &quot;400&quot;:&#10;          description: Missing refresh token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;        &quot;401&quot;:&#10;          description: Invalid or expired refresh token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;definitions:&#10;  User:&#10;    type: object&#10;    properties:&#10;      id:&#10;        type: integer&#10;        example: 1&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;      username:&#10;        type: string&#10;        example: johndoe&#10;      google_id:&#10;        type: string&#10;        example: 108976234234234234234&#10;      auth_provider:&#10;        type: string&#10;        example: google&#10;      created_at:&#10;        type: string&#10;        example: 2025-11-03T10:15:00Z&#10;  TokensResponse:&#10;    type: object&#10;    properties:&#10;      access_token:&#10;        type: string&#10;      refresh_token:&#10;        type: string&#10;      token_type:&#10;        type: string&#10;        example: bearer&#10;      user:&#10;        $ref: '#/definitions/User'&#10;  EmailLoginSuccess:&#10;    type: object&#10;    properties:&#10;      tokens:&#10;        $ref: '#/definitions/TokensResponse'&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;  RegisterSuccess:&#10;    type: object&#10;    description: Response after registration. If auto-login succeeds, tokens are present; otherwise only a message.&#10;    properties:&#10;      tokens:&#10;        $ref: '#/definitions/TokensResponse'&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;      message:&#10;        type: string&#10;        example: Registered successfully, but login failed&#10;  MessageResponse:&#10;    type: object&#10;    properties:&#10;      message:&#10;        type: string&#10;        example: Operation successful&#10;  ErrorResponse:&#10;    type: object&#10;    properties:&#10;      error:&#10;        type: string&#10;        example: Invalid credentials&#10;&#10;" />
              <option name="updatedContent" value="swagger: &quot;2.0&quot;&#10;info:&#10;  title: Google &amp; Email/Password Authentication Service API&#10;  version: 1.2.0&#10;  description: &gt;&#10;    This service handles Google OAuth2 authentication flow and simple email/password registration &amp; login.&#10;host: localhost:4001&#10;basePath: /api/v1&#10;schemes:&#10;  - http&#10;&#10;servers:&#10;  - url: http://localhost:4001/api/v1&#10;    description: Local development server&#10;    &#10;paths:&#10;  /auth/login:&#10;    get:&#10;      summary: Generate Google OAuth2 Authorization URL&#10;      description: Returns the Google OAuth2 consent screen URL where the user will log in.&#10;      tags:&#10;        - Google OAuth&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Authorization URL generated&#10;          schema:&#10;            type: object&#10;            properties:&#10;              auth_url:&#10;                type: string&#10;&#10;  /login:&#10;    post:&#10;      summary: Login with email and password&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: credentials&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              email:&#10;                type: string&#10;              password:&#10;                type: string&#10;            required:&#10;              - email&#10;              - password&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Login successful (sets httpOnly access &amp; refresh token cookies)&#10;          schema:&#10;            $ref: '#/definitions/EmailLoginSuccess'&#10;        &quot;400&quot;:&#10;          description: Invalid credentials&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /register:&#10;    post:&#10;      summary: Register a new user with email, password, and username&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: user&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              email:&#10;                type: string&#10;              password:&#10;                type: string&#10;              username:&#10;                type: string&#10;            required:&#10;              - email&#10;              - password&#10;              - username&#10;      responses:&#10;        &quot;201&quot;:&#10;          description: User registered successfully. If auto-login succeeds returns tokens; otherwise returns a message.&#10;          schema:&#10;            $ref: '#/definitions/RegisterSuccess'&#10;        &quot;400&quot;:&#10;          description: Registration failed&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /oauth2callback:&#10;    get:&#10;      summary: Handle Google OAuth2 Callback&#10;      description: Exchanges authorization code for tokens, verifies them, sets httpOnly cookies, and redirects to frontend.&#10;      tags:&#10;        - Google OAuth&#10;      parameters:&#10;        - name: code&#10;          in: query&#10;          required: true&#10;          type: string&#10;          description: Authorization code returned by Google&#10;      responses:&#10;        &quot;302&quot;:&#10;          description: &quot;Redirect to frontend dashboard on successful authentication (cookies set: access_token, refresh_token)&quot;&#10;        &quot;400&quot;:&#10;          description: Invalid credentials or token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /auth/logout:&#10;    post:&#10;      summary: Log out the authenticated user&#10;      description: Removes auth cookies (access_token, refresh_token) and returns a message.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Logout successful&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;&#10;  /delete-user:&#10;    delete:&#10;      summary: Delete a user by ID&#10;      description: Permanently removes a user from the database.&#10;      tags:&#10;        - Email Auth&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: user&#10;          required: true&#10;          schema:&#10;            type: object&#10;            properties:&#10;              user_id:&#10;                type: integer&#10;                example: 3&#10;            required:&#10;              - user_id&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: User deleted&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;        &quot;404&quot;:&#10;          description: User not found&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;&#10;  /:&#10;    get:&#10;      summary: Health Check&#10;      description: Check if the Authentication Service is running.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Service running successfully&#10;          schema:&#10;            $ref: '#/definitions/MessageResponse'&#10;&#10;  /users:&#10;    get:&#10;      summary: List all users&#10;      description: Returns an array of all registered users.&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Users fetched successfully&#10;          schema:&#10;            type: object&#10;            properties:&#10;              users:&#10;                type: array&#10;                items:&#10;                  $ref: '#/definitions/User'&#10;&#10;  /auth/refresh:&#10;    post:&#10;      summary: Refresh access token&#10;      description: Accepts a refresh token from cookie or request body and returns new access &amp; refresh tokens.&#10;      tags:&#10;        - Utility&#10;      consumes:&#10;        - application/json&#10;      parameters:&#10;        - in: body&#10;          name: refresh&#10;          required: false&#10;          schema:&#10;            type: object&#10;            properties:&#10;              refresh_token:&#10;                type: string&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Tokens refreshed successfully (sets new access_token cookie)&#10;          schema:&#10;            $ref: '#/definitions/TokensResponse'&#10;        &quot;400&quot;:&#10;          description: Missing refresh token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;        &quot;401&quot;:&#10;          description: Invalid or expired refresh token&#10;          schema:&#10;            $ref: '#/definitions/ErrorResponse'&#10;  /auth/me:&#10;    get:&#10;      summary: Get current authenticated user&#10;      tags:&#10;        - Utility&#10;      responses:&#10;        &quot;200&quot;:&#10;          description: Current user info&#10;          schema:&#10;            $ref: '#/definitions/User'&#10;definitions:&#10;  User:&#10;    type: object&#10;    properties:&#10;      id:&#10;        type: integer&#10;        example: 1&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;      username:&#10;        type: string&#10;        example: johndoe&#10;      google_id:&#10;        type: string&#10;        example: 108976234234234234234&#10;      auth_provider:&#10;        type: string&#10;        example: google&#10;      created_at:&#10;        type: string&#10;        example: 2025-11-03T10:15:00Z&#10;  TokensResponse:&#10;    type: object&#10;    properties:&#10;      access_token:&#10;        type: string&#10;      refresh_token:&#10;        type: string&#10;      token_type:&#10;        type: string&#10;        example: bearer&#10;      user:&#10;        $ref: '#/definitions/User'&#10;  EmailLoginSuccess:&#10;    type: object&#10;    properties:&#10;      tokens:&#10;        $ref: '#/definitions/TokensResponse'&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;  RegisterSuccess:&#10;    type: object&#10;    description: Response after registration. If auto-login succeeds, tokens are present; otherwise only a message.&#10;    properties:&#10;      tokens:&#10;        $ref: '#/definitions/TokensResponse'&#10;      email:&#10;        type: string&#10;        example: user@example.com&#10;      message:&#10;        type: string&#10;        example: Registered successfully, but login failed&#10;  MessageResponse:&#10;    type: object&#10;    properties:&#10;      message:&#10;        type: string&#10;        example: Operation successful&#10;  ErrorResponse:&#10;    type: object&#10;    properties:&#10;      error:&#10;        type: string&#10;        example: Invalid credentials" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/authentication-service/src/services/google_auth_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/authentication-service/src/services/google_auth_service.py" />
              <option name="originalContent" value="import os&#10;from google.oauth2 import id_token&#10;from google_auth_oauthlib.flow import Flow&#10;from google.auth.transport import requests&#10;from dotenv import load_dotenv&#10;&#10;load_dotenv()&#10;&#10;class GoogleAuthService:&#10;    def __init__(self):&#10;        self.client_id = os.getenv(&quot;GOOGLE_CLIENT_ID&quot;)&#10;        self.client_secret = os.getenv(&quot;GOOGLE_CLIENT_SECRET&quot;)&#10;        self.redirect_uri = os.getenv(&quot;GOOGLE_REDIRECT_URI&quot;)&#10;&#10;        service_dir = os.path.dirname(os.path.abspath(__file__))&#10;        root_dir = os.path.abspath(os.path.join(service_dir, &quot;..&quot;, &quot;..&quot;))&#10;        client_secret_path = os.path.join(root_dir, &quot;client_secret.json&quot;)&#10;&#10;        if not os.path.exists(client_secret_path):&#10;            raise FileNotFoundError(f&quot;client_secret.json not found at: {client_secret_path}&quot;)&#10;&#10;        self.flow = Flow.from_client_secrets_file(&#10;            client_secret_path,&#10;            scopes=[&#10;                &quot;https://www.googleapis.com/auth/userinfo.profile&quot;,&#10;                &quot;https://www.googleapis.com/auth/userinfo.email&quot;,&#10;                &quot;openid&quot;,&#10;            ],&#10;            redirect_uri=self.redirect_uri,&#10;        )&#10;&#10;    def get_authorization_url(self):&#10;        auth_url, _ = self.flow.authorization_url(prompt=&quot;consent&quot;)&#10;        return auth_url&#10;&#10;    def exchange_code_for_token(self, code):&#10;        self.flow.fetch_token(code=code)&#10;        credentials = self.flow.credentials&#10;        return credentials&#10;&#10;    def verify_token(self, token):&#10;        try:&#10;            idinfo = id_token.verify_oauth2_token(token, requests.Request(), self.client_id)&#10;            return idinfo&#10;        except Exception as e:&#10;            print(&quot;Token verification failed:&quot;, e)&#10;            return None&#10;" />
              <option name="updatedContent" value="import os&#10;from google.oauth2 import id_token&#10;from google_auth_oauthlib.flow import Flow&#10;from google.auth.transport import requests&#10;from dotenv import load_dotenv&#10;&#10;load_dotenv()&#10;&#10;class GoogleAuthService:&#10;    def __init__(self):&#10;        self.client_id = os.getenv(&quot;GOOGLE_CLIENT_ID&quot;)&#10;        self.client_secret = os.getenv(&quot;GOOGLE_CLIENT_SECRET&quot;)&#10;        # Ensure redirect_uri uses /api/v1/oauth2callback by default&#10;        self.redirect_uri = os.getenv(&quot;GOOGLE_REDIRECT_URI&quot;, &quot;http://localhost:4001/api/v1/oauth2callback&quot;)&#10;&#10;        service_dir = os.path.dirname(os.path.abspath(__file__))&#10;        root_dir = os.path.abspath(os.path.join(service_dir, &quot;..&quot;, &quot;..&quot;))&#10;        client_secret_path = os.path.join(root_dir, &quot;client_secret.json&quot;)&#10;&#10;        if not os.path.exists(client_secret_path):&#10;            raise FileNotFoundError(f&quot;client_secret.json not found at: {client_secret_path}&quot;)&#10;&#10;        self.flow = Flow.from_client_secrets_file(&#10;            client_secret_path,&#10;            scopes=[&#10;                &quot;https://www.googleapis.com/auth/userinfo.profile&quot;,&#10;                &quot;https://www.googleapis.com/auth/userinfo.email&quot;,&#10;                &quot;openid&quot;,&#10;            ],&#10;            redirect_uri=self.redirect_uri,&#10;        )&#10;&#10;    def get_authorization_url(self):&#10;        print(&quot;Using redirect URI:&quot;, self.flow.redirect_uri)&#10;        auth_url, _ = self.flow.authorization_url(prompt=&quot;consent&quot;)&#10;        return auth_url&#10;&#10;    def exchange_code_for_token(self, code):&#10;        self.flow.fetch_token(code=code)&#10;        credentials = self.flow.credentials&#10;        return credentials&#10;&#10;    def verify_token(self, token):&#10;        try:&#10;            idinfo = id_token.verify_oauth2_token(token, requests.Request(), self.client_id)&#10;            return idinfo&#10;        except Exception as e:&#10;            print(&quot;Token verification failed:&quot;, e)&#10;            return None" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>